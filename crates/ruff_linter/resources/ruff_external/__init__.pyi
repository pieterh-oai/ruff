from __future__ import annotations

from typing import Any, Callable, List, Literal, Mapping, Optional, Tuple
from typing_extensions import Unpack

Span = Tuple[int, int]
Reporter = Callable[[str, Optional[Span]], None]

__all__ = ["Context", "Node", "RawNode", "SemanticModel", "Binding", "Reference", "ScopeHandle"]


class Node:
    _kind: str
    _span: Span
    _text: str
    _repr: str
    node_id: int

    def __init__(self, kind: str, span: Span, text: str, repr_value: str, node_id: int) -> None: ...

    def __getitem__(self, key: str) -> Any: ...

    def get(self, key: str, default: Any = ...) -> Any: ...


class RawNode(Node):
    pass


from .visitor import VisitHandlers


class SemanticModel:
    def resolve_name(self, node: Node) -> Optional[str]: ...
    def resolve_binding(self, node: Node) -> Optional["Binding"]: ...
    def only_binding(self, node: Node) -> Optional["Binding"]: ...
    def resolve_qualified_name(self, node: Node) -> Optional[str]: ...
    def lookup_attribute(self, node: Node) -> Optional["Binding"]: ...
    def resolve_qualified_import_name(self, module: str, member: str) -> Optional[str]: ...
    def current_statement(self) -> Node: ...
    def current_statement_parent(self) -> Optional[Node]: ...
    def current_statements(self) -> List[Node]: ...
    def current_statement_id(self) -> Optional[int]: ...
    def current_statement_parent_id(self) -> Optional[int]: ...
    def current_statement_ids(self) -> List[int]: ...
    def parent_statement(self, node: Node) -> Optional[Node]: ...
    def parent_statement_id(self, node: Node) -> Optional[int]: ...
    def same_branch(self, left: Node, right: Node) -> bool: ...
    def dominates(self, left: Node, right: Node) -> bool: ...
    def current_expression(self) -> Optional[Node]: ...
    def current_expression_parent(self) -> Optional[Node]: ...
    def current_expression_grandparent(self) -> Optional[Node]: ...
    def current_expressions(self) -> List[Node]: ...
    def global_declaration(self, name: str) -> Optional[Span]: ...
    def resolve_nonlocal(self, name: str) -> Optional[Tuple["ScopeHandle", "Binding"]]: ...
    def shadowed_binding(self, node: Node) -> Optional["Binding"]: ...
    def shadowed_bindings(self, node: Node) -> List[Tuple["Binding", "Binding", bool]]: ...
    def at_top_level(self) -> bool: ...
    def in_async_context(self) -> bool: ...
    def in_nested_union(self) -> bool: ...
    def inside_optional(self) -> bool: ...
    def in_nested_literal(self) -> bool: ...
    def current_scope(self) -> "ScopeHandle": ...
    def current_scope_id(self) -> int: ...
    def current_scope_ids(self) -> List[int]: ...
    def current_scopes(self) -> List["ScopeHandle"]: ...
    def first_non_type_parent_scope(self) -> Optional["ScopeHandle"]: ...
    def first_non_type_parent_scope_id(self) -> Optional[int]: ...
    def match_builtin_expr(self, node: Node, name: str) -> bool: ...
    def resolve_builtin_symbol(self, node: Node) -> Optional[str]: ...
    def match_typing_expr(self, node: Node, name: str) -> bool: ...
    def match_typing_qualified_name(self, qualified_name: str, target: str) -> bool: ...
    def seen_typing(self) -> bool: ...
    def in_annotation(self) -> bool: ...
    def in_forward_reference(self) -> bool: ...
    def seen_module(self, name: str) -> bool: ...
    def has_builtin_binding(self, name: str) -> bool: ...
    def execution_context(self) -> Literal["runtime", "typing"]: ...
    def in_typing_only_annotation(self) -> bool: ...
    def visit(self, node: Node, /, **handlers: Unpack[VisitHandlers]) -> None: ...


class Binding:
    id: int
    name: str
    kind: str
    range: Span
    scope_id: int
    context: str
    is_global: bool
    is_nonlocal: bool
    is_builtin: bool
    is_used: bool
    is_alias: bool
    is_external: bool
    is_explicit_export: bool
    is_type_alias: bool
    is_unbound: bool
    is_unpacked_assignment: bool
    is_private: bool
    in_exception_handler: bool
    in_assert_statement: bool

    def statement(self, semantic: SemanticModel) -> Optional[Node]: ...
    def expression(self, semantic: SemanticModel) -> Optional[Node]: ...
    def references(self, semantic: SemanticModel) -> List["Reference"]: ...


class Reference:
    id: int
    range: Span
    node_id: Optional[int]
    scope_id: int
    is_load: bool
    in_typing_context: bool
    in_runtime_context: bool
    in_typing_only_annotation: bool
    in_runtime_evaluated_annotation: bool
    in_type_definition: bool
    in_type_checking_block: bool
    in_string_type_definition: bool
    in_dunder_all_definition: bool
    in_annotated_type_alias_value: bool
    in_assert_statement: bool


class ScopeHandle:
    id: int
    kind: str
    parent_id: Optional[int]
    node_id: Optional[int]
    is_async: bool
    uses_locals: bool


class Context:
    code: str
    name: str
    config: Mapping[str, Any]
    semantic: SemanticModel
    _report: Reporter

    def __init__(self, code: str, name: str, config: Mapping[str, Any], reporter: Reporter, semantic: SemanticModel) -> None: ...

    def report(self, message: str, span: Optional[Span] = ...) -> None: ...

from .nodes import *
from .nodes import __all__ as _node_all

__all__ = __all__ + _node_all
